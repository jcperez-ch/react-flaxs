import React, { Component } from 'react';
import { assign, forEach, identity, isEmpty, reduce, some } from 'lodash';
import hoistNonReactStatics from 'hoist-non-react-statics';
import { flaxs } from 'flaxs';

/**
 * Took it from connect module in redux.
 * @param  {ReactElement} WrappedComponent
 * @return {String}
 */
function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

/**
 * Default fuction that maps the props generated by 'mapStateToProps' function and
 * the actual props of the component.
 * @param  {object} mapedStateToProps
 * @param  {object} ownProps
 * @return {object}
 */
const defaultMapOwnProps = (mapedStateToProps, ownProps) => ({
  ...mapedStateToProps,
  ...ownProps,
});

export default function connect(
  mapStateToProps = identity,
  connectedStores = {},
  mapOwnProps = defaultMapOwnProps
) {
  if (process.env.NODE_ENV !== 'production' && isEmpty(connectedStores)) {
    /* eslint-disable no-console */
    console.error(`You need to connect your stores in the second attribute
      of the multiConnect decorator`);
    /* eslint-enable no-console */
    return ReactClass => ReactClass;
  }
  return function connection(ReactClass) {
    class Connection extends Component {
      static displayName = `multi(${getDisplayName(ReactClass)})`;
      constructor(props, context) {
        super(props, context);
        this.state = this.getMountedState();
        this.storeDidChange = this.storeDidChange.bind(this);
      }
      componentDidMount() {
        forEach(connectedStores, store => {
          store.addChangeListener(this.storeDidChange);
        });
        this.isComponentMounted = true;
      }
      shouldComponentUpdate(nextProps, nextState, nextContext) {
        const nextConnectedProps = this.getConnectedProps(nextProps, nextState);
        const connectedProps = this.getConnectedProps();
        return nextContext !== this.context || some(nextConnectedProps, (nextProp, propKey) =>
          nextProp !== connectedProps[propKey]
        );
      }
      componentWillUnmount() {
        forEach(connectedStores, store => {
          store.removeChangeListener(this.storeDidChange);
        });
        this.isComponentMounted = false;
      }
      getMountedState() {
        return reduce(connectedStores, (accStores, store, storeKey) => (
          assign(accStores, {
            [storeKey]: store.state,
          })
        ), {});
      }
      getConnectedProps(props = this.props, state = this.getMountedState()) {
        return mapOwnProps(mapStateToProps(state), props);
      }

      storeDidChange() {
        const newState = flaxs.store.state;
        // FIXME since events occur asynchronously, we can have the case where the component
        // listens for a change in the store, but the change occurs after it gets unmounted.
        if (this.isComponentMounted && newState !== this.getMountedState()) {
          this.setState(newState);
        }
      }
      render() {
        return React.createElement(ReactClass, this.getConnectedProps());
      }
    }

    return hoistNonReactStatics(Connection, ReactClass);
  };
}
